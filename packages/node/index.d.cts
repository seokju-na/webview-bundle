/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Bundle {
  descriptor(): BundleDescriptor
  getData(path: string): Buffer | null
  getDataChecksum(path: string): number | null
}

export declare class BundleBuilder {
  constructor(version?: Version | undefined | null)
  get version(): Version
  entryPaths(): Array<string>
  insertEntry(path: string, data: Buffer, contentType?: string | undefined | null, headers?: Record<string, string> | undefined | null): boolean
  removeEntry(path: string): boolean
  containsEntry(path: string): boolean
  build(options?: BuildOptions | undefined | null): Bundle
}

export declare class BundleDescriptor {
  header(): Header
  index(): Index
}

export declare class BundleProtocol {
  constructor(source: BundleSource)
  handle(method: HttpMethod, uri: string, headers?: Record<string, string> | undefined | null): Promise<HttpResponse>
}

export declare class BundleSource {
  constructor(config: BundleSourceConfig)
  listBundles(): Promise<Array<ListBundleItem>>
  loadVersion(bundleName: string): Promise<BundleSourceVersion | null>
  updateVersion(bundleName: string, version: string): Promise<void>
  filepath(bundleName: string): Promise<string>
  fetch(bundleName: string): Promise<Bundle>
  fetchDescriptor(bundleName: string): Promise<BundleDescriptor>
  writeRemoteBundle(bundleName: string, version: string, bundle: Bundle, metadata: BundleManifestMetadata): Promise<void>
}

export declare class Header {
  version(): Version
  indexEndOffset(): bigint
  indexSize(): number
}

export declare class Index {
  entries(): Record<string, IndexEntry>
  getEntry(path: string): IndexEntry | null
  containsPath(path: string): boolean
}

export declare class LocalProtocol {
  constructor(hosts: Record<string, string>)
  handle(method: HttpMethod, uri: string, headers?: Record<string, string> | undefined | null): Promise<HttpResponse>
}

export declare class Remote {
  constructor(endpoint: string, options?: RemoteOptions | undefined | null)
  listBundles(): Promise<Array<string>>
  getInfo(bundleName: string): Promise<RemoteBundleInfo>
  download(bundleName: string): Promise<[RemoteBundleInfo, Bundle, Buffer]>
  downloadVersion(bundleName: string, version: string): Promise<[RemoteBundleInfo, Bundle, Buffer]>
}

export declare class S3Uploader {
  constructor(bucket: string, options?: S3UploaderOptions | undefined | null)
  uploadBundle(bundleName: string, version: string, bundle: Bundle): Promise<void>
}

export declare class Updater {
  constructor(source: BundleSource, remote: Remote, options?: UpdaterOptions | undefined | null)
  listRemotes(): Promise<Array<string>>
  getUpdate(bundleName: string): Promise<BundleUpdateInfo>
  downloadUpdate(bundleName: string, version?: string | undefined | null): Promise<RemoteBundleInfo>
}

export interface BuildHeaderOptions {
  checksumSeed?: number
}

export interface BuildIndexOptions {
  checksumSeed?: number
}

export interface BuildOptions {
  header?: BuildHeaderOptions
  index?: BuildIndexOptions
  dataChecksumSeed?: number
}

export interface BundleManifestMetadata {
  etag?: string
  integrity?: string
  signature?: string
  lastModified?: string
}

export interface BundleSourceConfig {
  builtinDir: string
  remoteDir: string
  builtinManifestFilepath?: string
  remoteManifestFilepath?: string
}

export type BundleSourceKind =  'builtin'|
'remote';

export interface BundleSourceVersion {
  type: BundleSourceKind
  version: string
}

export interface BundleUpdateInfo {
  name: string
  version: string
  localVersion?: string
  isAvailable: boolean
  etag?: string
  integrity?: string
  signature?: string
  lastModified?: string
}

export type HttpMethod =  'get'|
'head'|
'options'|
'post'|
'put'|
'patch'|
'delete'|
'trace'|
'connect';

export interface HttpOptions {
  defaultHeaders?: Record<string, string>
  userAgent?: string
  timeout?: number
  readTimeout?: number
  connectTimeout?: number
  poolIdleTimeout?: number
  poolMaxIdlePerHost?: number
  referer?: boolean
  tcpNodelay?: boolean
  hickoryDns?: boolean
}

export interface HttpResponse {
  status: number
  headers: Record<string, string>
  body: Buffer
}

export interface IndexEntry {
  offset: number
  len: number
  isEmpty: boolean
  contentType: string
  contentLength: number
  headers: Record<string, string>
}

export type IntegrityAlgorithm =  'sha256'|
'sha384'|
'sha512';

export interface IntegrityMakerOptions {
  algorithm?: IntegrityAlgorithm
}

export type IntegrityPolicy =  'strict'|
'optional'|
'none';

export interface ListBundleItem {
  type: BundleSourceKind
  name: string
  version: string
  current: boolean
  metadata: BundleManifestMetadata
}

export declare function readBundle(filepath: string): Promise<Bundle>

export declare function readBundleFromBuffer(buffer: Buffer): Bundle

export interface RemoteBundleInfo {
  name: string
  version: string
  etag?: string
  integrity?: string
  signature?: string
  lastModified?: string
}

export interface RemoteOnDownloadData {
  downloadedBytes: number
  totalBytes: number
}

export interface RemoteOptions {
  http?: HttpOptions
  onDownload?: (data: RemoteOnDownloadData) => void
}

export interface S3UploaderOptions {
  accessKeyId?: string
  secretAccessKey?: string
  sessionToken?: string
  region?: string
  endpoint?: string
  roleArn?: string
  roleSessionName?: string
  externalId?: string
  integrityMaker?: IntegrityMakerOptions | ((data: Uint8Array) => Promise<string>)
  signatureSigner?: SignatureSignerOptions | ((data: Uint8Array) => Promise<string>)
  writeConcurrent?: number
  writeChunk?: number
  cacheControl?: string
  http?: HttpOptions
}

export type SignatureAlgorithm =  'ecdsaSecp256R1'|
'ecdsaSecp384R1'|
'ed25519'|
'rsaPkcs1V15'|
'rsaPss';

export interface SignatureSignerOptions {
  algorithm: SignatureAlgorithm
  key: SignatureSigningKeyOptions
}

export interface SignatureSigningKeyOptions {
  format: SigningKeyFormat
  data: string | Uint8Array
}

export interface SignatureVerifierOptions {
  algorithm: SignatureAlgorithm
  key: SignatureVerifyingKeyOptions
}

export interface SignatureVerifyingKeyOptions {
  format: VerifyingKeyFormat
  data: string | Uint8Array
}

export type SigningKeyFormat =  'sec1Der'|
'sec1Pem'|
'pkcs1Der'|
'pkcs1Pem'|
'pkcs8Der'|
'pkcs8Pem'|
'raw';

export interface UpdaterOptions {
  integrityPolicy?: IntegrityPolicy
  integrityChecker?: (data: Uint8Array, integrity: string) => Promise<boolean>
  signatureVerifier?: SignatureVerifierOptions | ((data: Uint8Array, signature: string) => Promise<boolean>)
}

export type VerifyingKeyFormat =  'spkiDer'|
'spkiPem'|
'pkcs1Der'|
'pkcs1Pem'|
'sec1'|
'raw';

export type Version =  'v1';

export declare function writeBundle(bundle: Bundle, filepath: string): Promise<bigint>

export declare function writeBundleIntoBuffer(bundle: Bundle): Buffer
