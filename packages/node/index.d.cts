/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Bundle {
  manifest(): BundleManifest
  getData(path: string): Buffer | null
  getDataChecksum(path: string): number | null
}
export type JsBundle = Bundle

export declare class BundleBuilder {
  constructor(version?: JsVersion | undefined | null)
  get version(): JsVersion
  entryPaths(): Array<string>
  insertEntry(path: string, data: Buffer, headers?: Record<string, string> | undefined | null): boolean
  removeEntry(path: string): boolean
  containsEntry(path: string): boolean
  build(options?: BuildOptions | undefined | null): Bundle
}
export type JsNapiBundleBuilder = BundleBuilder

export declare class BundleManifest {
  header(): Header
  index(): Index
}
export type JsBundleManifest = BundleManifest

export declare class BundleProtocol {
  constructor(source: JsBundleSource)
  handle(method: HttpMethod, uri: string, headers?: Record<string, string> | undefined | null): Promise<HttpResponse>
}
export type JsBundleProtocol = BundleProtocol

export declare class BundleSource {
  constructor(builtinDir: string, remoteDir: string)
  listBundles(): Promise<ListBundles>
  getFilepath(bundleName: string): Promise<string | null>
  getVersion(bundleName: string): Promise<BundleSourceVersion | null>
  setVersion(bundleName: string, version: string): Promise<void>
  saveVersions(): Promise<void>
  isExists(bundleName: string, version: BundleSourceVersion): Promise<boolean>
  fetch(bundleName: string): Promise<Bundle>
  fetchManifest(bundleName: string): Promise<BundleManifest>
}
export type JsBundleSource = BundleSource

export declare class Header {
  version(): JsVersion
  indexEndOffset(): bigint
  indexSize(): number
}
export type JsHeader = Header

export declare class Index {
  entries(): Record<string, IndexEntry>
  getEntry(path: string): IndexEntry | null
  containsPath(path: string): boolean
}
export type JsIndex = Index

export declare class LocalProtocol {
  constructor(hosts: Record<string, string>)
  handle(method: HttpMethod, uri: string, headers?: Record<string, string> | undefined | null): Promise<HttpResponse>
}
export type JsLocalProtocol = LocalProtocol

export declare class Remote {
  constructor(endpoint: string, options?: RemoteOptions | undefined | null)
  listBundles(): Promise<Array<string>>
  getInfo(bundleName: string): Promise<RemoteBundleInfo>
  download(bundleName: string): Promise<[RemoteBundleInfo, Bundle, Buffer]>
  downloadVersion(bundleName: string, version: string): Promise<[RemoteBundleInfo, Bundle, Buffer]>
}
export type JsRemote = Remote

export declare class S3Uploader {
  constructor(bucket: string, options?: S3UploaderOptions | undefined | null)
  uploadBundle(bundleName: string, version: string, bundle: Bundle): Promise<void>
}
export type JsS3Uploader = S3Uploader

export declare class Updater {
  constructor(source: BundleSource, remote: Remote, options?: UpdaterOptions | undefined | null)
  listRemotes(): Promise<Array<string>>
  getUpdate(bundleName: string): Promise<BundleUpdateInfo>
  downloadUpdate(bundleName: string, version?: string | undefined | null): Promise<RemoteBundleInfo>
  applyUpdate(bundleName: string, version: string): Promise<void>
}
export type JsUpdater = Updater

export interface BuildHeaderOptions {
  checksumSeed?: number
}

export interface BuildIndexOptions {
  checksumSeed?: number
}

export interface BuildOptions {
  header?: JsBuildHeaderOptions
  index?: JsBuildIndexOptions
  dataChecksumSeed?: number
}

export interface BundleSourceVersion {
  type: BundleSourceVersionType
  version: string
}

export type BundleSourceVersionType =  'builtin'|
'remote';

export interface BundleUpdateInfo {
  name: string
  version: string
  localVersion?: string
  isAvailable: boolean
  integrity?: string
  signature?: string
}

export type HttpMethod =  'get'|
'head'|
'options'|
'post'|
'put'|
'patch'|
'delete'|
'trace'|
'connect';

export interface HttpOptions {
  defaultHeaders?: Record<string, string>
  userAgent?: string
  timeout?: number
  readTimeout?: number
  connectTimeout?: number
  poolIdleTimeout?: number
  poolMaxIdlePerHost?: number
  referer?: boolean
  tcpNodelay?: boolean
  hickoryDns?: boolean
}

export interface HttpResponse {
  status: number
  headers: Record<string, string>
  body: Buffer
}

export interface IndexEntry {
  offset: number
  len: number
  isEmpty: boolean
  headers: Record<string, string>
}

export type IntegrityAlgorithm =  'sha256'|
'sha384'|
'sha512';

export interface IntegrityMakerOptions {
  algorithm?: IntegrityAlgorithm
}

export type IntegrityPolicy =  'strict'|
'optional'|
'none';

export type JsSignatureAlgorithm =  'ecdsaSecp256R1'|
'ecdsaSecp384R1'|
'ed25519'|
'rsaPkcs1V15'|
'rsaPss';

export type JsSigningKeyFormat =  'sec1Der'|
'sec1Pem'|
'pkcs1Der'|
'pkcs1Pem'|
'pkcs8Der'|
'pkcs8Pem'|
'raw';

export type JsVerifyingKeyFormat =  'spkiDer'|
'spkiPem'|
'pkcs1Der'|
'pkcs1Pem'|
'sec1'|
'raw';

export interface ListBundles {
  builtin: Array<string>
  remote: Array<string>
}

export declare function readBundle(filepath: string): Promise<Bundle>

export declare function readBundleFromBuffer(buffer: Buffer): Bundle

export interface RemoteBundleInfo {
  name: string
  version: string
  integrity?: string
  signature?: string
}

export interface RemoteOnDownloadData {
  downloadedBytes: number
  totalBytes: number
}

export interface RemoteOptions {
  http?: HttpOptions
  onDownload?: (data: RemoteOnDownloadData) => void
}

export interface S3UploaderOptions {
  accessKeyId?: string
  secretAccessKey?: string
  sessionToken?: string
  region?: string
  endpoint?: string
  roleArn?: string
  roleSessionName?: string
  externalId?: string
  integrityMaker?: IntegrityMakerOptions | ((data: Uint8Array) => Promise<string>)
  signatureSigner?: SignatureSignerOptions | ((data: Uint8Array) => Promise<string>
  writeConcurrent?: number
  writeChunk?: number
  cacheControl?: string
  http?: HttpOptions
}

export interface SignatureSignerOptions {
  algorithm: JsSignatureAlgorithm
  key: JsSignatureSigningKeyOptions
}

export interface SignatureSigningKeyOptions {
  format: JsSigningKeyFormat
  data: string | Buffer
}

export interface SignatureVerifierOptions {
  algorithm: JsSignatureAlgorithm
  key: JsSignatureVerifyingKeyOptions
}

export interface SignatureVerifyingKeyOptions {
  format: JsVerifyingKeyFormat
  data: string | Buffer
}

export interface UpdaterOptions {
  integrityPolicy?: IntegrityPolicy
  integrityChecker?: JsCallback<[Buffer, string], Promise<boolean>>
  signatureVerifier?: JsSignatureVerifier
}

export type Version =  'v1';

export declare function writeBundle(bundle: Bundle, filepath: string): Promise<bigint>

export declare function writeBundleIntoBuffer(bundle: Bundle): Buffer
